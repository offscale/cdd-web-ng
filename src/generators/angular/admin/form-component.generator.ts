import { ClassDeclaration, Project, Scope } from 'ts-morph';

import { Resource, SwaggerDefinition } from '@src/core/types/index.js';
import { camelCase, pascalCase, singular } from "@src/core/utils/index.js";
import { SwaggerParser } from '@src/core/parser.js';
import { FormModelBuilder } from "@src/analysis/form-model.builder.js";
import { FormAnalysisResult, FormControlModel } from "@src/analysis/form-types.js";

import { commonStandaloneImports } from './common-imports.js';
import { generateFormComponentHtml } from './html/form-component-html.builder.js';
import { generateFormComponentScss } from './html/form-component-scss.builder.js';
import { FormInitializerRenderer } from './form.renderer.js';

/**
 * Orchestrates the generation of a complete Angular standalone form component.
 * It uses FormModelBuilder for analysis and FormInitializerRenderer for code generation.
 */
export class FormComponentGenerator {
    /**
     * @param project The ts-morph Project instance.
     * @param parser The SwaggerParser instance.
     */
    constructor(private readonly project: Project, private readonly parser: SwaggerParser) {
    }

    public generate(resource: Resource, outDir: string): { usesCustomValidators: boolean } {
        const formDir = `${outDir}/${resource.name}/${resource.name}-form`;
        this.project.getFileSystem().mkdirSync(formDir);

        // Phase 1: Analysis
        const builder = new FormModelBuilder(this.parser);
        const analysis = builder.build(resource);

        // Phase 2: Emission
        const tsResult = this.generateFormComponentTs(resource, formDir, analysis);
        this.generateFormComponentHtml(resource, analysis, formDir);
        this.generateFormComponentScss(resource, formDir);

        return { usesCustomValidators: tsResult.usesCustomValidators };
    }

    private generateFormComponentTs(resource: Resource, outDir: string, analysis: FormAnalysisResult): { usesCustomValidators: boolean } {
        const componentName = `${pascalCase(resource.modelName)}FormComponent`;
        const serviceName = `${pascalCase(resource.name)}Service`;
        const formFilePath = `${outDir}/${resource.name}-form.component.ts`;
        const sourceFile = this.project.createSourceFile(formFilePath, undefined, { overwrite: true });
        // The builder creates the main interface with this name
        const formInterfaceName = analysis.interfaces.find(i => i.isTopLevel)?.name || `${pascalCase(resource.modelName)}Form`;

        const oneOfImports = analysis.polymorphicOptions?.map(o => o.modelName).join(', ') || '';

        sourceFile.addStatements([
            `import { Component, OnInit, computed, inject, signal, effect, ChangeDetectionStrategy, DestroyRef } from '@angular/core';`,
            `import { takeUntilDestroyed } from '@angular/core/rxjs-interop';`,
            `import { FormBuilder, FormGroup, FormArray, Validators, FormControl, ReactiveFormsModule } from '@angular/forms';`,
            `import { ActivatedRoute, Router, RouterModule } from '@angular/router';`,
            ...commonStandaloneImports.map(a => `import { ${a[0]} } from "${a[1]}";`),
            `import { MatSnackBar } from '@angular/material/snack-bar';`,
            `import { ${serviceName} } from '../../../services/${camelCase(resource.name)}.service';`,
            `import { ${resource.modelName}${oneOfImports ? ', ' + oneOfImports : ''} } from '../../../models';`,
            analysis.usesCustomValidators ? `import { CustomValidators } from '../../shared/custom-validators';` : ''
        ].filter(Boolean));

        // Helper function to find a control model by name, searching recursively
        const findControlInModel = (controls: FormControlModel[], name: string): FormControlModel | undefined => {
            for (const control of controls) {
                if (control.name === name) return control;
                if (control.nestedControls) {
                    const nested = findControlInModel(control.nestedControls, name);
                    if (nested) return nested;
                }
            }
            // Also check polymorphic options, as their controls are not in the main tree
            for (const polyOption of analysis.polymorphicOptions || []) {
                const nested = findControlInModel(polyOption.controls, name);
                if (nested) return nested;
            }
            return undefined;
        };

        // Emit all Interfaces generated by analysis
        analysis.interfaces.forEach(iface => {
            sourceFile.addInterface({
                name: iface.name,
                isExported: iface.isTopLevel,
                properties: iface.properties.map(prop => {
                    // Find the control model that corresponds to this property name
                    const control = findControlInModel(analysis.topLevelControls, prop.name);

                    // If a control isn't found (e.g., a polymorphic sub-form property),
                    // we search those specifically.
                    if (!control) {
                        console.warn(`[Generator] Control model for property '${prop.name}' in interface '${iface.name}' not found in main tree. This may happen with polymorphic sub-forms.`);
                        return { name: prop.name, type: 'any' }; // Fallback
                    }

                    // --- THIS IS THE CORE OF THE REFACTOR ---
                    // Build the final Angular-specific type string from the agnostic IR.
                    let finalType: string;
                    switch (control.controlType) {
                        case 'group':
                            finalType = `FormGroup<${control.dataType}>`;
                            break;
                        case 'array':
                            if (control.nestedControls) { // Array of FormGroups
                                const itemType = control.dataType.replace('[]', '');
                                finalType = `FormArray<FormGroup<${itemType}>>`;
                            } else { // Array of FormControls (primitives)
                                const itemType = control.dataType.replace(/[()]/g, '').replace('[]', '');
                                finalType = `FormArray<FormControl<${itemType}>>`;
                            }
                            break;
                        case 'control':
                        default:
                            finalType = `FormControl<${control.dataType}>`;
                            break;
                    }
                    return { name: control.name, type: finalType };
                })
            });
        });

        const componentClass = sourceFile.addClass({
            name: componentName, isExported: true,
            decorators: [{
                name: 'Component',
                arguments: [`{
                    selector: 'app-${resource.name}-form',
                    standalone: true,
                    imports: [
                        ReactiveFormsModule,
                        RouterModule,
                        ${commonStandaloneImports.map(a => a[0]).join(',\n    ')}
                    ],
                    templateUrl: './${resource.name}-form.component.html',
                    styleUrl: './${resource.name}-form.component.scss',
                    changeDetection: ChangeDetectionStrategy.OnPush
                }`]
            }],
            implements: ['OnInit']
        });

        this.addProperties(componentClass, resource, serviceName, formInterfaceName, analysis);

        if (analysis.isPolymorphic) {
            componentClass.addConstructor({
                statements: writer => writer.write(`effect(() => {
    const type = this.form.get(this.discriminatorPropName)?.value;
    if (type) { this.updateFormForPetType(type); }
});`)
            });
        }

        this.addNgOnInit(componentClass, resource, serviceName, analysis.hasFormArrays || analysis.isPolymorphic);
        this.addInitForm(componentClass, formInterfaceName, analysis.topLevelControls);

        if (analysis.isPolymorphic) this.addPolymorphismLogic(componentClass, resource, analysis);
        if (analysis.hasFileUploads) this.addFileHandling(componentClass);
        if (analysis.hasFormArrays) this.addFormArrayHelpers(componentClass, analysis.topLevelControls);
        if (analysis.hasFormArrays || analysis.isPolymorphic) this.addPatchForm(componentClass, resource, analysis);
        if (analysis.isPolymorphic) this.addGetPayload(componentClass);

        this.addOnSubmit(componentClass, resource, serviceName, analysis.isPolymorphic);
        this.addOnCancelMethod(componentClass);

        sourceFile.formatText({ ensureNewLineAtEndOfFile: true });
        return { usesCustomValidators: analysis.usesCustomValidators };
    }

    private addProperties(classDeclaration: ClassDeclaration, resource: Resource, serviceName: string, formInterfaceName: string, analysis: FormAnalysisResult): void {
        classDeclaration.addProperties([
            { name: 'fb', isReadonly: true, initializer: 'inject(FormBuilder)', docs: ["Injects Angular's FormBuilder service."] },
            { name: 'route', isReadonly: true, initializer: 'inject(ActivatedRoute)' },
            { name: 'router', isReadonly: true, initializer: 'inject(Router)' },
            { name: 'snackBar', isReadonly: true, initializer: 'inject(MatSnackBar)' },
            { name: `${camelCase(serviceName)}`, isReadonly: true, type: serviceName, initializer: `inject(${serviceName})` },
            { name: `form!: FormGroup<${formInterfaceName}>`, docs: ["The main reactive form group for this component."] },
            { name: 'destroyRef', scope: Scope.Private, isReadonly: true, initializer: 'inject(DestroyRef)' },
            { name: 'id = signal<string | null>(null)' },
            { name: 'isEditMode = computed(() => !!this.id())' },
            { name: 'formTitle', initializer: `computed(() => this.isEditMode() ? 'Edit ${resource.modelName}' : 'Create ${resource.modelName}')` },
        ]);

        if (analysis.isPolymorphic && analysis.discriminatorOptions) {
            classDeclaration.addProperties([
                {
                    name: 'discriminatorOptions',
                    isReadonly: true,
                    initializer: JSON.stringify(analysis.discriminatorOptions),
                    docs: ["The available options for the polymorphic discriminator."]
                },
                {
                    name: 'discriminatorPropName',
                    isReadonly: true,
                    scope: Scope.Private,
                    initializer: `'${analysis.discriminatorPropName}'`
                }
            ]);
        }

        const processedEnums = new Set<string>();
        const findEnums = (properties: FormControlModel[]) => {
            for (const prop of properties) {
                const schema = prop.schema;
                if (!schema) continue;
                const itemsSchema = (schema.type === 'array' ? schema.items : schema) as SwaggerDefinition | undefined;
                if (!itemsSchema) continue;
                if (itemsSchema.enum) {
                    const optionsName = `${pascalCase(prop.name)}Options`;
                    if (!processedEnums.has(optionsName)) {
                        classDeclaration.addProperty({
                            name: optionsName,
                            isReadonly: true,
                            initializer: JSON.stringify(itemsSchema.enum)
                        });
                        processedEnums.add(optionsName);
                    }
                }
                if (prop.nestedControls) {
                    findEnums(prop.nestedControls);
                }
            }
        };
        findEnums(analysis.topLevelControls);
    }

    private addNgOnInit(classDeclaration: ClassDeclaration, resource: Resource, serviceName: string, needsComplexPatch: boolean): void {
        const getByIdOp = resource.operations.find(op => op.action === 'getById');
        const patchCall = needsComplexPatch ? 'this.patchForm(entity)' : 'this.form.patchValue(entity as any)';
        let body = `this.initForm();\nconst id = this.route.snapshot.paramMap.get('id');\nif (id) {\n  this.id.set(id);`;
        if (getByIdOp?.methodName) {
            body += `\n  this.${camelCase(serviceName)}.${getByIdOp.methodName}(id).pipe(takeUntilDestroyed(this.destroyRef)).subscribe(entity => {\n    ${patchCall};\n  });`;
        }
        body += '\n}';
        classDeclaration.addMethod({ name: 'ngOnInit', statements: body });
    }

    private addInitForm(classDeclaration: ClassDeclaration, interfaceName: string, controls: FormControlModel[]): void {
        const formControls = controls
            .map(c => `'${c.name}': ${FormInitializerRenderer.renderControlInitializer(c)}`)
            .join(',\n      ');
        const statement = `this.form = new FormGroup<${interfaceName}>({\n      ${formControls}\n    });`;
        classDeclaration.addMethod({ name: 'initForm', scope: Scope.Private, statements: statement });
    }

    private addFormArrayHelpers(classDeclaration: ClassDeclaration, topLevelControls: FormControlModel[]): void {
        const findArrays = (ctrls: FormControlModel[]): FormControlModel[] => {
            let found: FormControlModel[] = [];
            for (const c of ctrls) {
                if (c.controlType === 'array' && c.nestedControls) found.push(c);
            }
            return found;
        };

        const formArrayProps = findArrays(topLevelControls);

        formArrayProps.forEach(prop => {
            const arrayName = prop.name;
            const singularPascal = pascalCase(singular(arrayName));
            const singularCamel = camelCase(singular(arrayName));
            const arrayGetterName = `${singularCamel}Array`;

            const arrayItemInterfaceName = prop.nestedFormInterface || 'any';

            classDeclaration.addGetAccessor({
                name: arrayGetterName,
                returnType: `FormArray<FormGroup<${arrayItemInterfaceName}>>`,
                statements: `return this.form.get('${arrayName}') as FormArray<FormGroup<${arrayItemInterfaceName}>>;`,
                docs: [`Getter for the ${singularCamel} FormArray.`]
            });

            const createMethod = classDeclaration.addMethod({
                name: `create${singularPascal}`,
                scope: Scope.Private,
                parameters: [{ name: 'item?', type: 'any' }],
                returnType: `FormGroup<${arrayItemInterfaceName}>`
            });

            const initializerString = FormInitializerRenderer.renderFormArrayItemInitializer(prop.nestedControls!);
            createMethod.setBodyText(`return ${initializerString};`);

            classDeclaration.addMethod({
                name: `add${singularPascal}`,
                statements: `this.${arrayGetterName}.push(this.create${singularPascal}());`,
            });
            classDeclaration.addMethod({
                name: `remove${singularPascal}`,
                parameters: [{ name: 'index', type: 'number' }],
                statements: `this.${arrayGetterName}.removeAt(index);`,
            });
        });
    }

    private addOnSubmit(classDeclaration: ClassDeclaration, resource: Resource, serviceName: string, hasPolymorphism: boolean): void {
        const createOp = resource.operations.find(op => op.action === 'create');
        const updateOp = resource.operations.find(op => op.action === 'update');
        if (!createOp?.methodName && !updateOp?.methodName) return;

        const payloadExpr = hasPolymorphism ? 'this.getPayload()' : 'this.form.getRawValue()';
        let body = `if (!this.form.valid) { return; }\nconst finalPayload = ${payloadExpr};\n`;

        if (createOp?.methodName && updateOp?.methodName) {
            body += `const action$ = this.isEditMode()\n  ? this.${camelCase(serviceName)}.${updateOp.methodName}(this.id()!, finalPayload)\n  : this.${camelCase(serviceName)}.${createOp.methodName}(finalPayload);\n`;
        } else if (updateOp?.methodName) {
            body += `if (!this.isEditMode()) { console.error('Form is not in edit mode, but no create operation is available.'); return; }\n`;
            body += `const action$ = this.${camelCase(serviceName)}.${updateOp.methodName}(this.id()!, finalPayload);\n`;
        } else if (createOp?.methodName) {
            body += `if (this.isEditMode()) { console.error('Form is in edit mode, but no update operation is available.'); return; }\n`;
            body += `const action$ = this.${camelCase(serviceName)}.${createOp.methodName}(finalPayload);\n`;
        }
        body += `action$.pipe(takeUntilDestroyed(this.destroyRef)).subscribe({\n  next: () => {\n    this.snackBar.open('${resource.modelName} saved successfully!', 'Close', { duration: 3000 });\n    this.router.navigate(['../'], { relativeTo: this.route });\n  },\n  error: (err) => {\n    console.error('Error saving ${resource.modelName}', err);\n    this.snackBar.open('Error saving ${resource.modelName}', 'Close', { duration: 5000, panelClass: 'error-snackbar' });\n  }\n});`;
        classDeclaration.addMethod({ name: 'onSubmit', statements: body });
    }

    private addOnCancelMethod(classDeclaration: ClassDeclaration): void {
        classDeclaration.addMethod({ name: 'onCancel', statements: `this.router.navigate(['../'], { relativeTo: this.route });` });
    }

    private addPatchForm(classDeclaration: ClassDeclaration, resource: Resource, analysis: FormAnalysisResult): void {
        const arrayProps = analysis.topLevelControls.filter(c => c.controlType === 'array' && c.nestedControls);
        const oneOfPropName = analysis.discriminatorPropName;

        const allComplexProps = [...arrayProps.map(p => p.name), ...(oneOfPropName ? [oneOfPropName] : [])];
        if (allComplexProps.length === 0) return;

        let body = `const { ${allComplexProps.join(', ')}, ...rest } = entity;\n`;
        body += 'this.form.patchValue(rest as any);\n\n';

        arrayProps.forEach(prop => {
            const arrayGetterName = `${camelCase(singular(prop.name))}Array`;
            const createItemMethodName = `create${pascalCase(singular(prop.name))}`;
            body += `if (Array.isArray(entity.${prop.name})) {\n`;
            body += `  this.${arrayGetterName}.clear();\n`;
            body += `  entity.${prop.name}.forEach((item: any) => this.${arrayGetterName}.push(this.${createItemMethodName}(item)));\n`;
            body += `}\n`;
        });

        if (analysis.isPolymorphic && analysis.polymorphicOptions) {
            const dPropName = analysis.discriminatorPropName!;
            body += `\nconst petType = (entity as any).${dPropName};\n`;
            body += `if (petType) {\n`;
            body += `  this.form.get(this.discriminatorPropName)?.setValue(petType, { emitEvent: true });\n`;

            analysis.polymorphicOptions.forEach(opt => {
                const subSchemaName = opt.modelName;
                const typeName = opt.discriminatorValue;
                body += `  if (this.is${subSchemaName}(entity)) {\n`;
                body += `    (this.form.get('${typeName}') as FormGroup)?.patchValue(entity as any);\n  }\n`;
            });
            body += `}\n`;
        }
        classDeclaration.addMethod({
            name: 'patchForm',
            scope: Scope.Private,
            parameters: [{ name: 'entity', type: resource.modelName || 'any' }],
            statements: body
        });
    }

    private addPolymorphismLogic(classDeclaration: ClassDeclaration, resource: Resource, analysis: FormAnalysisResult) {
        const updateMethod = classDeclaration.addMethod({
            name: 'updateFormForPetType',
            scope: Scope.Private,
            parameters: [{ name: 'type', type: 'string' }]
        });

        const options = analysis.polymorphicOptions || [];

        if (options.length > 0) {
            let switchBody = `this.discriminatorOptions.forEach(opt => this.form.removeControl(opt as any));\n\nswitch(type) {\n`;
            options.forEach(opt => {
                const subFormProps = opt.controls.map(c => `'${c.name}': ${FormInitializerRenderer.renderControlInitializer(c)}`).join(', ');
                switchBody += `  case '${opt.discriminatorValue}':\n`;
                switchBody += `    this.form.addControl('${opt.subFormName}' as any, this.fb.group({ ${subFormProps} }));\n`;
                switchBody += '    break;\n';
            });
            switchBody += '}';
            updateMethod.setBodyText(switchBody);
        } else {
            updateMethod.setBodyText(`{}`);
        }

        classDeclaration.addMethod({
            name: 'isPetType',
            parameters: [{ name: 'type', type: 'string' }],
            returnType: 'boolean',
            statements: `return this.form.get(this.discriminatorPropName)?.value === type;`
        });

        options.forEach(opt => {
            const subSchemaName = opt.modelName;
            const typeName = opt.discriminatorValue;
            classDeclaration.addMethod({
                name: `is${subSchemaName}`,
                scope: Scope.Private,
                parameters: [{ name: 'entity', type: resource.modelName }],
                returnType: `entity is ${subSchemaName}`,
                statements: `return (entity as any).${analysis.discriminatorPropName} === '${typeName}';`
            });
        });
    }

    private addGetPayload(classDeclaration: ClassDeclaration) {
        const body = `const baseValue = this.form.getRawValue();
const petType = (baseValue as any)[this.discriminatorPropName];
if (!petType) return baseValue;
const subFormValue = (this.form.get(petType) as FormGroup | undefined)?.value || {};
const payload = { ...baseValue, ...subFormValue };
this.discriminatorOptions.forEach(opt => delete (payload as any)[opt]);
return payload;`;
        classDeclaration.addMethod({ name: 'getPayload', scope: Scope.Private, statements: body });
    }

    private addFileHandling(classDeclaration: ClassDeclaration) {
        classDeclaration.addMethod({
            name: 'onFileSelected',
            parameters: [{ name: 'event', type: 'Event' }, { name: 'formControlName', type: 'string' }],
            statements: `const file = (event.target as HTMLInputElement).files?.[0];\nif (file) {\n    this.form.patchValue({ [formControlName]: file } as any);\n    this.form.get(formControlName)?.markAsDirty();\n}`
        });
    }

    private generateFormComponentHtml(resource: Resource, analysis: FormAnalysisResult, outDir: string): void {
        const htmlFilePath = `${outDir}/${resource.name}-form.component.html`;
        const content = generateFormComponentHtml(resource, analysis);
        this.project.getFileSystem().writeFileSync(htmlFilePath, content);
    }

    private generateFormComponentScss(resource: Resource, outDir: string): void {
        const scssFilePath = `${outDir}/${resource.name}-form.component.scss`;
        const content = generateFormComponentScss();
        this.project.getFileSystem().writeFileSync(scssFilePath, content);
    }
}

// src/service/emit/type/type.generator.ts

import { Project, SourceFile } from 'ts-morph';
import { SwaggerParser } from '../../../core/parser.js';
import { GeneratorConfig, SwaggerDefinition } from '../../../core/types.js';
import { getTypeScriptType, pascalCase } from '../../../core/utils.js';

export class TypeGenerator {
    constructor(
        private readonly parser: SwaggerParser,
        private readonly project: Project,
        private readonly config: GeneratorConfig
    ) {}

    public generate(outDir: string): void {
        const modelsDir = `${outDir}/models`;
        this.project.getFileSystem().mkdirSync(modelsDir);
        const sourceFile = this.project.createSourceFile(`${modelsDir}/index.ts`, '', { overwrite: true });
        this.addCommonAngularImports(sourceFile);
        sourceFile.addStatements(`/**\n * This file is generated by a tool. Do not edit directly.\n * Generated by openapi-angular-generator.\n */`);

        for (const schema of this.parser.schemas) {
            if (schema.definition.enum) {
                this.generateEnum(sourceFile, schema.name, schema.definition);
            } else {
                this.generateInterface(sourceFile, schema.name, schema.definition);
            }
        }
        this.addRequestOptionsInterface(sourceFile);
    }

    private generateEnum(sourceFile: SourceFile, name: string, definition: SwaggerDefinition): void {
        const isStringEnum = (definition.enum?.every(e => typeof e === 'string')) ?? false;
        if (isStringEnum && this.config.options.enumStyle === 'enum') {
            sourceFile.addEnum({ name, isExported: true, members: definition.enum!.map(val => ({ name: pascalCase(val as string), value: val as string })) });
        } else {
            sourceFile.addTypeAlias({ name, isExported: true, type: definition.enum?.map(v => typeof v === 'string' ? `'${v.replace(/'/g, "\\'")}'` : v).join(' | ') ?? 'any' });
        }
    }

    private generateInterface(sourceFile: SourceFile, name: string, definition: SwaggerDefinition): void {
        const knownTypes = this.parser.schemas.map(s => s.name);

        if (definition.properties || (definition.type === 'object' && definition.additionalProperties)) {
            sourceFile.addInterface({
                name,
                isExported: true,
                properties: Object.entries(definition.properties || {}).map(([key, propDef]) => ({
                    name: /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key) ? key : `'${key}'`,
                    type: getTypeScriptType(propDef, this.config, knownTypes),
                    hasQuestionToken: !(definition.required || []).includes(key),
                    // THIS IS THE FIX: Reverted from `jsDocs` back to `docs` for property signatures.
                    docs: propDef.description ? [propDef.description] : [],
                })),
                ...(definition.additionalProperties && {
                    indexSignatures: [{
                        keyName: 'key', keyType: 'string',
                        returnType: definition.additionalProperties === true ? 'any' : getTypeScriptType(definition.additionalProperties as SwaggerDefinition, this.config, knownTypes)
                    }]
                })
            });
        } else {
            const typeString = getTypeScriptType(definition, this.config, knownTypes);
            sourceFile.addTypeAlias({ name, isExported: true, type: typeString });
        }
    }

    private addCommonAngularImports(sourceFile: SourceFile): void {
        sourceFile.addImportDeclaration({ moduleSpecifier: '@angular/common/http', namedImports: ['HttpHeaders', 'HttpContext', 'HttpParams'] });
    }

    private addRequestOptionsInterface(sourceFile: SourceFile): void {
        sourceFile.addInterface({
            name: 'RequestOptions', isExported: true,
            properties: [
                { name: 'headers?', type: 'HttpHeaders | { [header: string]: string | string[]; }' },
                { name: 'context?', type: 'HttpContext' },
                { name: 'params?', type: 'HttpParams | { [param: string]: string | number | boolean | ReadonlyArray<string | number | boolean>; }' },
                { name: 'reportProgress?', type: 'boolean' },
                { name: 'withCredentials?', type: 'boolean' },
            ]
        });
    }
}

import { describe, it, expect } from 'vitest';
import { Project } from 'ts-morph';
import { ServiceGenerator } from '../../../../src/service/emit/service/service.generator.js';
import { SwaggerParser } from '../../../../src/core/parser.js';
import { GeneratorConfig } from '../../../../src/core/types.js';

describe('Unit: ServiceGenerator (Coverage)', () => {

    const runGenerator = (spec: object, config: GeneratorConfig) => {
        const project = new Project({ useInMemoryFileSystem: true });
        const parser = new SwaggerParser(spec as any, config);
        const serviceGen = new ServiceGenerator(parser, project, config);
        // The service generator expects PathInfo objects, which are generated by `extractPaths`.
        // We pass the operations array directly, which is what `generateServiceFile` expects.
        serviceGen.generateServiceFile('Test', (spec as any).operations, '/generated/services');
        return project.getSourceFileOrThrow('/generated/services/test.service.ts');
    };

    it('should use customizeMethodName function when provided', () => {
        const spec = {
            // **FIX**: The test runner passes `operations` not `paths`.
            operations: [{ path: '/test', operationId: 'get_test_data', method: 'GET' }]
        };
        const config: GeneratorConfig = {
            input: '', output: '',
            options: {
                dateType: 'string', enumStyle: 'enum',
                customizeMethodName: (opId) => `custom_${opId}`
            }
        };
        const sourceFile = runGenerator(spec, config);
        const serviceClass = sourceFile.getClassOrThrow('TestService');
        expect(serviceClass.getMethod('custom_get_test_data')).toBeDefined();
    });

    it('should throw if customizeMethodName is used but operationId is missing', () => {
        const spec = {
            // **FIX**: The test runner passes `operations` not `paths`
            operations: [{ path: '/test', method: 'GET' }] // No operationId
        };
        const config: GeneratorConfig = {
            input: '', output: '',
            options: {
                dateType: 'string', enumStyle: 'enum',
                customizeMethodName: (opId) => opId
            }
        };
        // We need to wrap the call in a function for toThrow to catch it
        const generate = () => runGenerator(spec, config);
        expect(generate).toThrow('Operation ID is required for method name customization');
    });

    it('should generate method with header parameters', () => {
        const spec = {
            // **FIX**: Provide a complete operation object
            operations: [{
                path: '/test', // This was the missing property causing crashes
                method: 'GET',
                operationId: 'getWithHeader',
                parameters: [{ name: 'X-My-Header', in: 'header', required: true, schema: { type: 'string' } }]
            }]
        };
        const config: GeneratorConfig = { input: '', output: '', options: { dateType: 'string', enumStyle: 'enum' } };

        const sourceFile = runGenerator(spec, config);
        const method = sourceFile.getClassOrThrow('TestService').getMethodOrThrow('getWithHeader');

        // Check parameter generation
        const headerParam = method.getParameters().find(p => p.getName() === 'xMyHeader');
        expect(headerParam).toBeDefined();
        expect(headerParam?.getType().getText()).toBe('string');

        // Check method body generation
        const bodyText = method.getBodyText();
        // **FIX**: Update assertions to match modern, correct code
        expect(bodyText).toContain("let headers = new HttpHeaders(options?.headers);");
        expect(bodyText).toContain("headers = headers.append('X-My-Header', String(xMyHeader));");
        // **FIX**: This assertion is for obsolete code and should be removed
        // expect(bodyText).toContain('observe: observe as any,');
    });
});
